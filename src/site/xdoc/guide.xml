<?xml version="1.0"?>
<document>

    <properties>
        <title>JGGApi Guide</title>
        <author>Mateusz Szczap</author>
    </properties>

    <body>
		<title>JGGApi Guide</title>
        <section name="Getting Started with JGGApi">

			<subsection name="Induction">
				<p>
				JGGApi is a library that was designed to be used by high-level developers. It handles low level
				binary Gadu-Gadu protocol implementation. High level developers can use well described interfaces to interact
				with Gadu-Gadu server as most of protocol details is hidden. 
				</p>			
				<p>
				One of the most important classes in JGGApi is a <code>Session</code> class.
				Well described interfaces can be accessed from <code>Session</code> instance, they are
				so-called JGGApi services:
				</p>
				<p>
				<b>JGGApi services:</b>
				<ul>
					<li>IConnectionService - connecting and disconnecting.</li>
					<li>ILoginService - logging and logging out.</li>
					<li>IMessageService - sending and receiving messages.</li>
					<li>IPresenceService - updating own status and listening for changes of statuses of users from buddy list.</li>
					<li>IPublicDirectoryService - searching in public directory service, reading and writing personal information.</li>
					<li>IContactListService - importing and exporting of contact list.</li>
					<li>IRegistrationService - registering and unregistering new account, changing password, sending forgotten password by e-mail.</li>
				</ul>
				</p>
				</subsection>
				<subsection name="Session lifecycle">
				<p>
				<code>Session</code> can be in various states. We can check current <code>SessionState</code>
				by invoking <code>getSessionState()</code> method on <code>Session</code> object.
				</p>
				<source>
<![CDATA[
ISession session = ...
SessionState sessionState = session.getSessionState();				
]]>
				</source>
				<p>
				<b>List of all available session states:</b>
				<ul>
					<li>SessionState.CONNECTION_AWAITING</li>
					<li>SessionState.CONNECTING</li>
					<li>SessionState.CONNECTED</li>
					<li>SessionState.AUTHENTICATION_AWAITING</li>
					<li>SessionState.LOGGED_IN</li>
					<li>SessionState.DISCONNECTING</li>
					<li>SessionState.DISCONNECTED</li>
					<li>SessionState.LOGGED_OUT</li>
					<li>SessionState.CONNECTION_ERROR</li>
				</ul>
				</p>
				<p>
				After session creation, <code>Session</code> instance is in <code>SessionState.CONNECTION_AWAITING</code>.
				When <code>connect()</code> method is invoked session state changes to <code>SessionState.CONNECTING</code>.
				After connection to Gadu-Gadu server is established the session state changes to <code>SessionState.CONNECTED</code>.
				Next phase is the authentication of user, therefore session state is in <code>SessionState.AUTHENTICATION_AWAITING</code>.
				After logging in session changes to <code>SessionState.LOGGED_IN</code>.
				</p>
				<p>
				In <code>SessionState.LOGGED_IN</code> it is possible to send messages, change status,
				import, export contact list and search information in public directory. Basically, it means
				session is ready for interaction with Gadu-Gadu server.
				</p>
				<p>
				When there is an unexpected error that occurs during interaction with Gadu-Gadu server session
				state changes to <code>SessionState.CONNECTION_ERROR</code> and this means you can disconnect from server.
				</p>
				<p>
				If you want to be notified of session state changes you can register as <code>SessionStateLister</code>
				in <code>Session</code> object.
				</p>
				<p>
				Code snippet:
				<source>
<![CDATA[
ISession session = ...
session.addSessionStateListener(new SessionStateListener() {
	public void sessionStateChanged(final SessionState oldSessionState, final SessionState newSessionState) {
		//add handling here
	}
});
]]>
				</source>
				</p>
			</subsection>
			<subsection name="Connecting and disconnecting">
				<p>
				Create <code>Session</code> object by invoking static method from SessionFactory. After that create 
				a <code>LoginContext</code> instance. <code>LoginContext</code> contains various information that are
				of high importance in logging process. It holds Gadu-Gadu uin and password for it.
				In addition, it contains information about initial status, local and remote IP addresses,
				maximal image size that the user accepts and initial list of monitored users.
				Note that monitored users list also includes list of users that are banned,
				ie. the ones from which we do not wish to receive any notification and messages.
				</p>
				<p>		
				In order to connect to Gadu-Gadu server one has to use <code>ConnectionService</code>
				that can be referenced from previously created <code>Session</code> object.		
				After that add <code>ConnectionListener</code> to listen for connection related events.
				</p>
				<p>
				<b>Code snippet:</b>
				<source>
<![CDATA[
final ISession session = SessionFactory.createSession();
final LoginContext loginContext = new LoginContext(1336843, "dupadupa");
session.getConnectionService().addConnectionListener(new ConnectionListener.Stub() {
	public void connectionEstablished() throws GGException {
		System.out.println("Connection established.");
	}
});
session.getConnectionService().connect();
]]>
				</source>
				</p>
				<p>
				The code above code snippet establishes socket connection to Gadu-Gadu server. It is important to note that it does
				<b>NOT</b> log in user. When connection to server is successful, <code>connectionEstablished()</code> method
				from connection handler class is invoked and SessionState changes to AUTHENTICATION_AWAITING.
				</p>
				<p>
				In order to disconnect from Gadu-Gadu server you have to invoke <code>disconnect()</code> method
				on <code>ConnectionService</code>. After that connection handler class that implements
				<code>ConnectionListener</code> interface is notified and <code>connectionClosed()</code>
				method is invoked. After listener method is triggered the SessionState changes to DISCONNECTED.
				It is important to notice that disconnect method can always be invoked, regardless of the current session state. 
				</p>
				<p>
				<b>Code snippet:</b>
				<source>
final ISession session = SessionFactory.createSession();
session.getConnectionService().addConnectionListener(new ConnectionListener.Stub() {
	public void connectionClosed() throws GGException {
		System.out.println("Connection closed.");
	}
});
session.getConnectionService().disconnect();
				</source>
				</p>
			</subsection>
			<subsection name="Logging in and logging out">
				<p>
				In order to log in connection to Gadu-Gadu server must be established.
				</p>
				<p>
				One can log in using <code>LoginService</code>. If the uin and password match Gadu-Gadu server
				replies that logging was successful or that server did not authenticate. In order to receive such events one has to register in
				<code>LoginService</code> as a login handler that implements <code>LoginListener</code>
				interface.
				</p>
				<p>
				Code snippet:
				<source>
<![CDATA[
ISession session = ...
ILoginService loginService = session.getLoginService();
loginService.addLoginListener(new LoginListener.Stub() {
	public void loginOK() {
		System.out.println("Login OK.");
	}

	public void loginFailed() {
		System.out.println("Login Failed.");
	}
});
]]>
				</source>
				</p>
				<p>
				If you want to log out from Gadu-Gadu server you have to invoke <code>logout</code>
				method on <code>LoginService</code>. After doing that status will be set to unavailable
				and there will be no way to send messages or interact with Gadu-Gadu server.
				</p>
				<p>
				Code snippet:
				<source>
<![CDATA[
ISession session = ...
ILoginService loginService = session.getLoginService();
loginService.logout();
]]>
				</source>
				</p>
				<p>
				There is also another method to logout that takes description as a <code>java.lang.String</code>
				and return date as <code>java.util.Date</code>. Please consult Java Docs to get more information on
				this.
				</p>
			</subsection>
					
			<subsection name="Sending and receiving messages">
				<p>
				In order to send and receive messages one has to use <code>MessageService</code>
				that can be accessed via <code>Session</code> object.
				Before sending, an outgoing message has to be created. There is a <code>
				OutgoingMessage</code> class that has three static methods to create it's instance.
				The most common static method is: <code>OutgoingMessage.createNewMessage(176798, "body")</code>
				</p>
				<p>
				The above method simply creates a new <code>OutgoingMessage</code> instance.
				The first parameter is the number of recipient and the second one is the body of the
				message to be send.
				</p>
				<p>
				After creating <code>OutgoingMessage</code> object one can send it through <code>MessageService</code>.
				In order to do it please invoke <code>sendMessage</code> method from <code>MessageService</code>.
				</p>
				<p>
				Code snippet:
				<source>
<![CDATA[
ISession session = ...
IMessageService messageService = session.getMessageService();
OutgoingMessage outMessage = OutgoingMessage.createNewMessage(176798, "body");
messageService.sendMessage(outMessage);
]]>
				</source>
				</p>
				<p>
				If one wants to receive messages from other users one has to register as a <code>MessageListener</code>
				in <code>MessageService</code>.
				</p>
				<p>
				Code snippet:
				<source>
<![CDATA[
ISession session = ...
IMessageService messageService = session.getMessageService();
messageService.addMessageListener(new MessageListener.Stub() {
	public void messageArrived(final IncomingMessage incommingMessage) {
		System.out.println("MessageArrived, from user: "+incommingMessage.getUin());
		System.out.println("MessageBody: "+incommingMessage.getMessageBody());
		System.out.println("MessageID: "+incommingMessage.getMessageID());
		System.out.println("MessageStatus: "+incommingMessage.getMessageClass());
		System.out.println("MessageTime: "+incommingMessage.getMessageDate());
	}
});
]]>
				</source>
				</p>
				<p>
				There is also possibilty to receive confirmation whether a certain outgoing message
				was delivered or not. In order to do that one has to register as <code>MessageListener</code>
				in <code>LoginService</code>. After message that was previously sent is delivered Gadu-Gadu sents
				confirmation packet and the client is notified by invocation of <code>messageDelivered</code> method
				from <code>MessageListener</code>. The message can be identified by an unique <code>messageID</code>
				that is generated when one creates <code>OutgoingMessage</code>.
				</p>
				<p>
				Code snippet:
				<source>
<![CDATA[
ISession session = ...
IMessageService messageService = session.getMessageService();
messageService.addMessageListener(new MessageListener.Stub() {
	public void messageDelivered(int uin, int messageID, MessageStatus deliveryStatus) {
		System.out.println("MessageDelivered, fromUser: "+String.valueOf(uin));
		System.out.println("MessageDelivered, messageID: "+String.valueOf(messageID));
		System.out.println("MessageDelivered, messageStatus: "+deliveryStatus);
	}
});
OutgoingMessage outMessage = OutgoingMessage.createNewMessage(176798, "body");
messageService.sendMessage(outMessage);
]]>
				</source>
				</p>
			</subsection>
		</section>
    </body>
</document>