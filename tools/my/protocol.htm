<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- (C) Copyright 2001-2002 by ekg team --><HTML><HEAD>
<META http-equiv=Content-type content="text/html; charset=iso-8859-2">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=black bgColor=white>
<CENTER>
<TABLE width=600>
  <TBODY>
  <TR>
    <TD>
      <CENTER>
      <H1>Protokó³ Gadu-Gadu</H1>
      <H3>&copy; Copyright 2001, 2002 <A 
      href="file:///D:/tmp/doc/protocol.html#ch4">Autorzy</A></H3></CENTER>
      <HR>

      <H2>0. Informacje wstêpne</H2>
      <P>Opis protoko³u u¿ywanego przez Gadu-Gadu bazuje na do¶wiadczeniach 
      przeprowadzonych przez autorów oraz informacjach nadsy³anych przez 
      u¿ytkowników. ¯aden klient Gadu-Gadu nie zosta³ skrzywdzony podczas badañ. 
      Reverse-engineering opiera³ siê g³ównie na analizie pakietów wysy³anych 
      miêdzy klientem a serwerem. </P>
      <HR>

      <H2>1. Protokó³ Gadu-Gadu</H2>
      <H3>1.1. Format pakietów</H3>
      <P>Podobnie jak coraz wiêksza ilo¶æ komunikatorów, Gadu-Gadu korzysta z 
      protoko³u TCP/IP. Ka¿dy pakiet zawiera na pocz±tku dwa sta³e pola: </P>
      <P><PRE>        struct gg_header {
		int type;	<I>/* typ pakietu */</I>
		int length;	<I>/* d³ugo¶æ reszty pakietu */</I>
	};
</PRE>
      <P></P>
      <P>Wszystkie zmienne liczbowe s± zgodne z kolejno¶ci± bajtów maszyn 
      Intela, czyli Little-Endian. </P>
      <P>Przy opisie struktur, za³o¿ono, ¿e <TT>char</TT> ma rozmiar 1 bajtu, 
      <TT>short</TT> 2 bajtów, <TT>int</TT> 4 bajtów. U¿ywaj±c innych 
      architektur ni¿ i386 nale¿y zwróciæ szczególn± uwagê na rozmiar typów 
      zmiennych i kolejno¶æ znaków. </P>
      <P>Pola, który znaczenie jest nieznane, lub nie do koñca jasne, oznaczono 
      przedrostkiem <TT>unknown</TT>. </P>
      <HR>

      <H3>1.2. Zanim siê po³±czymy</H3>
      <P>¯eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ 
      przez chwilê przegl±darkê WWW i po³±czyæ siê z hostem 
      <TT>appmsg.gadu-gadu.pl</TT>. 
      <P>
      <P><PRE>	GET /appsvc/appmsg.asp?fmnumber=<B>NUMER</B> HTTP/1.0
	Host: appmsg.gadu-gadu.pl
	User-Agent: Mozilla/4.7 [en] (Win98; I)
	Pragma: no-cache
</PRE>
      <P></P>Oryginalny klient mo¿e wys³aæ jeden z podanych identyfikatorów 
      przegl±darki: 
      <P>
      <P><PRE>	Mozilla/4.04 [en] (Win95; I ;Nav)
	Mozilla/4.7 [en] (Win98; I)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)
</PRE>
      <P></P>Nowsze wersje (od 4.6.2) korzystaj± z innego skryptu: 
      <P>
      <P><PRE>	GET /appsvc/appmsg2.asp?fmnumber=<B>NUMER</B>&amp;version=<B>WERSJA</B>&amp;fmt=<B>FORMAT</B>&amp;lastmsg=<B>WIADOMO¦Æ</B>
	Host: appmsg.gadu-gadu.pl
	User-Agent: ...
	Pragma: no-cache
</PRE>
      <P></P>Gdzie <B>NUMER</B> jest numerem klienta, <B>WERSJA</B> jest wersj± 
      klienta, <B>FORMAT</B> okre¶la czy wiadomo¶æ systemowa bêdzie przesy³ana 
      czystym tekstem (brak zmiennej "fmt") czy w HTMLu (jakakolwiek jej 
      warto¶.), a <B>WIADOMO¦Æ</B> jest numerem ostatnio otrzymanej wiadomo¶ci 
      systemowej. Na postawione w ten sposób zapytanie, serwer powinien 
      odpowiedzieæ na przyk³ad tak: 
      <P>
      <P><PRE>	HTTP/1.0 200 OK
	
	0 217.17.41.84:8074 217.17.41.84
</PRE>
      <P></P>Pierwsze pole jest numerem wiadomo¶ci systemowej, a drugie i 
      trzecie podaj± nam namiary na w³a¶ciwy serwer. Je¶li serwer jest 
      niedostêpny, zamiast adresu IP jest zwracany tekst 
      ,,<TT>notoperating</TT>''. Je¿eli po³±czenie z portem 8074 nie powiedzie 
      siê z jakich¶ powodów, mo¿na siê ³±czyæ na port 443. 
      <P>Je¶li pierwsza liczba nie jest równa zero, zaraz po nag³ówku znajduje 
      siê wiadomo¶æ systemowa, lub je¶li linia zaczyna siê od znaku 
      ,,<TT>@</TT>'', adres strony, któr± nale¿y otworzyæ w przegl±darce. 
      <HR>

      <H3>1.3. Logowanie siê</H3>
      <P>Po po³±czeniu siê portem 8074 lub 443 serwera Gadu-Gadu, dostajemy 
      pakiet typu <TT>0x0001</TT>, który na potrzeby tego dokumentu nazwiemy: 
      <P>
      <P><PRE>	#define GG_WELCOME 0x0001
</PRE>
      <P></P>Reszta pakietu zawiera liczbê, na podstawie której liczony jest 
      hash z has³a klienta: 
      <P>
      <P><PRE>	struct gg_welcome {
		int seed;	<I>/* klucz szyfrowania has³a */</I>
	};
</PRE>
      <P></P>Kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania 
      <P>
      <P><PRE>	#define GG_LOGIN 0x000c
</PRE>
      <P></P>Musimy podaæ kilka informacji: 
      <P>
      <P><PRE>	struct gg_login {
		int uin;		<I>/* numer klienta */</I>
		int hash;		<I>/* hash has³a */</I>
		int status;		<I>/* pocz±tkowy stan */</I>
		int version;		<I>/* wersja klienta */</I>
		int local_ip;		<I>/* mój adres ip */</I>
		short local_port;	<I>/* port, na którym s³ucham */</I>
	};
</PRE>
      <P></P>Hash has³a w pierwszych wersjach by³ liczony w do¶æ prosty sposób, 
      ale niestety z któr±¶ zmian± protoko³u wprowadzono nowy algorytm: 
      <P>
      <P><PRE>	int gg_login_hash(char *password, int seed)
	{
		unsigned int x, y, z;

		y = seed;

		for (x = 0; *password; password++) {
			x = (x &amp; 0xffffff00) | *password;
			y ^= x;
			y += x;
			x &lt;&lt;= 8;
			y ^= x;
			x &lt;&lt;= 8;
			y -= x;
			x &lt;&lt;= 8;
			y ^= x;

			z = y &amp; 0x1f;
			y = (y &lt;&lt; z) | (y &gt;&gt; (32 - z));
		}

		return y;
	}
</PRE>
      <P></P>Liczba oznaczaj±ca wersjê mo¿e byæ jedn± z poni¿szych: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Warto¶æ<B></B></B></TD>
          <TD><B>Wersje klientów</B></TD></TR>
        <TR>
          <TD><TT>0x18</TT></TD>
          <TD>5.0.1, 4.9.3</TD></TR>
        <TR>
          <TD><TT>0x17</TT></TD>
          <TD>4.9.2</TD></TR>
        <TR>
          <TD><TT>0x16</TT></TD>
          <TD>4.9.1</TD></TR>
        <TR>
          <TD><TT>0x15</TT></TD>
          <TD>4.8.9</TD></TR>
        <TR>
          <TD><TT>0x14</TT></TD>
          <TD>4.8.3, 4.8.1</TD></TR>
        <TR>
          <TD><TT>0x11</TT></TD>
          <TD>4.6.10, 4.6.1</TD></TR>
        <TR>
          <TD><TT>0x10</TT></TD>
          <TD>4.5.22, 4.5.21, 4.5.19, 4.5.17, 4.5.15</TD></TR>
        <TR>
          <TD><TT>0x0f</TT></TD>
          <TD>4.5.12</TD></TR>
        <TR>
          <TD><TT>0x0b</TT></TD>
          <TD>4.0.30, 4.0.29, 4.0.28, 4.0.25</TD></TR></TBODY></TABLE></CENTER>
      <P>Oczywi¶cie nie s± to wszystkie mo¿liwe wersje klientów, lecz te, które 
      uda³o siê z³apaæ na wolno¶ci. Najbezpieczniej bêdzie przedstawiaæ siê jako 
      ta wersja, której w³asno¶ci u¿ywamy. Wiadomo, ¿e wersje 4.0 nie 
      obs³ugiwa³y trybu ukrytego, tylko dla znajomych itd. 
      <P>W najnowszej wersji protoko³u jest dodatkowa maska na wersjê: 
      <P>
      <P><PRE>	#define GG_HAS_AUDIO_MASK 0x40000000
</PRE>
      <P></P>która mówi nam, ¿e dany klient mo¿e prowadziæ rozmowy g³osowe. 
      <P>Je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi pakiet typu: 
      <P>
      <P><PRE>      #define GG_LOGIN_OK 0x0003
</PRE>
      <P></P>o zerowej d³ugo¶ci, lub w przypadku b³êdu pakiet: 
      <P>
      <P><PRE>      #define GG_LOGIN_FAILED 0x0009
</PRE>
      <P></P>Od wersji 4.9.3 (protokó³ 0x18), mo¿liwe jest równie¿ wykorzystanie 
      przekierowania portów. Je¶li chcemy wykorzystaæ, nale¿y zamiast pakietu 
      GG_LOGIN wys³aæ nastêpuj±cy: 
      <P>
      <P><PRE>	#define GG_LOGIN_EXT 0x0013

	struct gg_login_ext {
		int uin;		<I>/* numer klienta */</I>
		int hash;		<I>/* hash has³a */</I>
		int status;		<I>/* pocz±tkowy stan */</I>
		int version;		<I>/* wersja klienta */</I>
		int local_ip;		<I>/* mój adres ip */</I>
		short local_port;	<I>/* port, na którym s³ucham */</I>
		int external_ip;	<I>/* zewnêtrzny adres ip */</I>
		short external_port;	<I>/* zewnêtrzny port */</I>
	};
</PRE>
      <P></P>
      <HR>

      <H3>1.4. Zmiana stanu</H3>
      <P>Gadu-Gadu przewiduje kilka stanów klienta, które zmieniamy pakietem 
      typu: 
      <P>
      <P><PRE>	#define GG_NEW_STATUS 0x0002

	struct gg_new_status {
		int status;		<I>/* na jaki zmieniæ? */</I>
		char description[];	<I>/* opis, nie musi wyst±piæ */</I>
		int time;		<I>/* czas, nie musi wyst±piæ */</I>
	}
</PRE>
      <P></P>Mo¿liwe stany to: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Etykieta</B></TD>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD><TT>GG_STATUS_NOT_AVAIL</TT></TD>
          <TD><TT>0x0001</TT></TD>
          <TD>Niedostêpny</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_NOT_AVAIL_DESCR</TT></TD>
          <TD><TT>0x0015</TT></TD>
          <TD>Niedostêpny (z opisem)</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_AVAIL</TT></TD>
          <TD><TT>0x0002</TT></TD>
          <TD>Dostêpny</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_AVAIL_DESCR</TT></TD>
          <TD><TT>0x0004</TT></TD>
          <TD>Dostêpny (z opisem)</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_BUSY</TT></TD>
          <TD><TT>0x0003</TT></TD>
          <TD>Zajêty</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_BUSY_DESCR</TT></TD>
          <TD><TT>0x0005</TT></TD>
          <TD>Zajêty (z opisem)</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_INVISIBLE</TT></TD>
          <TD><TT>0x0014</TT></TD>
          <TD>Niewidoczny</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_INVISIBLE_DESCR</TT></TD>
          <TD><TT>0x0016</TT></TD>
          <TD>Niewidoczny z opisem</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_BLOCKED</TT></TD>
          <TD><TT>0x0006</TT></TD>
          <TD>Zablokowany</TD></TR>
        <TR>
          <TD><TT>GG_STATUS_FRIENDS_MASK</TT></TD>
          <TD><TT>0x8000</TT></TD>
          <TD>Maska bitowa oznaczaj±ca tryb tylko dla 
      przyjació³</TD></TR></TBODY></TABLE></CENTER>
      <P>Nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ 
      stan na <TT>GG_STATUS_NOT_AVAIL</TT> lub 
      <TT>GG_STATUS_NOT_AVAIL_DESCR</TT>. Je¶li ma byæ widoczny tylko dla 
      przyjació³, nale¿y dodaæ <TT>GG_STATUS_FRIENDS_MASK</TT> do normalnej 
      warto¶ci stanu. 
      <P>Je¶li wybieramy stan opisowy, nale¿y do³±czyæ ci±g znaków zakoñczony 
      zerem oraz ewentualny czas powrotu w postaci ilo¶ci sekund od 1 stycznia 
      1970r (UTC). Maksymalna d³ugo¶æ opisu wynosi 40 znaków plus zero plus 4 
      bajty na godzinê powrotu, co razem daje 45 bajtów. 
      <HR>

      <H3>1.5. Ludzie przychodz±, ludzie odchodz±</H3>
      <P>Zaraz po zalogowaniu mo¿emy wys³aæ serwerowi nasz± listê kontaktów, 
      ¿eby dowiedzieæ siê, czy s± w danej chwili dostêpni. Pakiet zawiera 
      maksymalnie 409 struktur <TT>gg_notify</TT>: 
      <P><PRE>	#define GG_NOTIFY 0x0010
	
	struct gg_notify {
		int uin;	<I>/* numerek danej osoby */</I>
		char type;	<I>/* rodzaj u¿ytkownika */</I>
	};
</PRE>
      <P></P>Gdzie pole <TT>type</TT> przyjmuje nastêpuj±ce warto¶ci: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Etykieta</B></TD>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD><TT>GG_USER_OFFLINE</TT></TD>
          <TD><TT>0x01</TT></TD>
          <TD>U¿ytkownik, dla którego bêdziemy niedostêpni</TD></TR>
        <TR>
          <TD><TT>GG_USER_NORMAL</TT></TD>
          <TD><TT>0x03</TT></TD>
          <TD>Zwyk³y u¿ytkownik dodany do listy kontkatów</TD></TR>
        <TR>
          <TD><TT>GG_USER_BLOCKED</TT></TD>
          <TD><TT>0x04</TT></TD>
          <TD>U¿ytkownik, którego wiadomo¶ci nie chcemy 
        otrzymywaæ</TD></TR></TBODY></TABLE></CENTER><!-- Adam pisa³, ¿e jest to bitmapa, w której 0x01 znaczy otwarte okienko
rozmowy z dan± osob±, ale wygl±da³oby to co najmniej dziwnie, wiêc
upro¶ci³em trochê ca³± sprawê. -->
      <P>Je¶li nie mamy nikogo na li¶cie wysy³amy pakiet: 
      <P><PRE>	#define GG_LIST_EMPTY 0x0012
</PRE>
      <P></P>o zerowej d³ugo¶ci. 
      <P>Je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej 
      struktur <TT>gg_notify_reply</TT>: 
      <P>
      <P><PRE>	#define GG_NOTIFY_REPLY 0x000c	/* tak, to samo co GG_LOGIN */
	
	struct gg_notify_reply {
		int uin;		/* numerek */
		int status;		/* status danej osoby */
		int remote_ip;		/* adres ip delikwenta */
		short remote_port;	/* port, na którym s³ucha klient */
		int version;		/* wersja klienta */
		short unknown1;		/* znowu port? */
		char description[];	/* opis, nie musi wyst±piæ */
		int time;		/* czas, nie musi wyst±piæ */
	};
</PRE>
      <P></P>Wiêkszo¶æ pól powinna byæ zrozumia³a. <TT>remote_port</TT> poza 
      zwyk³ym portem mo¿e przyjmowaæ równie¿ poni¿sze warto¶ci: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD>0</TD>
          <TD>Klient nie obs³uguje bezpo¶rednich po³±czeñ</TD></TR>
        <TR>
          <TD>1</TD>
          <TD>Klient ³±czy siê zza NAT lub innej formy maskarady</TD></TR>
        <TR>
          <TD>2</TD>
          <TD>Klient nie ma nas w swojej li¶cie 
      kontaktów</TD></TR></TBODY></TABLE></CENTER>
      <P>Zdarzaj± siê te¿ inne ,,nietypowe'' warto¶ci, ale ich znaczenie nie 
      jest jeszcze do koñca znane. 
      <P>Je¶li dany klient jest w stanie z podanym opisem, najpierw dostaniemy 
      informacjê osobnym pakietem o nim, pó¼niej paczkê struktur 
      <TT>gg_notify_reply</TT> z lud¼mi, którzy nie maj± ustawionych opisów. 
      <P>¯eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany 
      pakiet. Jego format jest identyczny jak przy <TT>GG_NOTIFY</TT>. 
      <P>
      <P><PRE>	#define GG_ADD_NOTIFY 0x000d
	
	struct gg_add {
		int uin;	<I>/* numerek */</I>
		char type;	<I>/* rodzaj u¿ytkownika */</I>
	};
</PRE>
      <P></P>By usun±æ z listy kontaktów, wysy³a siê podobny pakiet: 
      <P>
      <P><PRE>	#define GG_REMOVE_NOTIFY 0x000e
	
	struct gg_add {
		int uin;	<I>/* numerek */</I>
		char type;	<I>/* rodzaj u¿ytkownika */</I>
	};
</PRE>
      <P></P>Je¶li kto¶ opu¶ci Gadu-Gadu lub zmieni stan, otrzymamy pakiet: 
      <P>
      <P><PRE>	#define GG_STATUS 0x0002
	
	struct gg_status {
		int uin;	<I>/* numerek */</I>
		int status;	<I>/* nowy stan */</I>
	};
</PRE>
      <P></P>
      <HR>

      <H3>1.6. Wysy³anie wiadomo¶ci</H3>
      <P>Wiadomo¶ci wysy³a siê nastêpuj±cym typem pakietu: 
      <P>
      <P><PRE>	#define GG_SEND_MSG 0x000b

	struct gg_send_msg {
		int recipient;		<I>/* numer odbiorcy */</I>
		int seq;		<I>/* numer sekwencyjny */</I>
		int class;		<I>/* klasa wiadomo¶ci */</I>
		char message[];		<I>/* tre¶æ */</I>
	};
</PRE>
      <P></P>Numer sekwencyjny jest wykorzystywany przy potwierdzeniu 
      dostarczenia lub zakolejkowania pakietu. Nie jest wykluczone, ¿e w jakis 
      sposób odró¿nia siê ró¿ne rozmowy za pomoc± czê¶ci bajtów, ale raczej nie 
      powinno mieæ to ma znaczenia. Klasa wiadomo¶ci pozwala odró¿niæ, czy 
      wiadomo¶æ ma siê pojawiæ w osobnym okienku czy jako kolejna linijka w 
      okienku rozmowy. Jest to mapa bitowa, wiêc najlepiej ignorowaæ te bity, 
      których znaczenia nie znamy: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Etykieta</B></TD>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD><TT>GG_CLASS_QUEUED</TT></TD>
          <TD><TT>0x0001</TT></TD>
          <TD>Bit ustawiany wy³±cznie przy odbiorze wiadomo¶ci, gdy wiadomo¶æ 
            zosta³a wcze¶niej zakolejkowania z powodu nieobecno¶ci</TD></TR>
        <TR>
          <TD><TT>GG_CLASS_MSG</TT></TD>
          <TD><TT>0x0004</TT></TD>
          <TD>Wiadomo¶æ ma siê pojawiæ w osobnym okienku</TD></TR>
        <TR>
          <TD><TT>GG_CLASS_CHAT</TT></TD>
          <TD><TT>0x0008</TT></TD>
          <TD>Wiadomo¶æ jest czê¶ci± tocz±cej siê rozmowy i zostanie 
            wy¶wietlona w istniej±cym okienku</TD></TR>
        <TR>
          <TD><TT>GG_CLASS_CTCP</TT></TD>
          <TD><TT>0x0010</TT></TD>
          <TD>Wiadomo¶æ jest przeznaczona dla klienta Gadu-Gadu i nie powinna 
            byæ wy¶wietlona u¿ytkownikowi.</TD></TR>
        <TR>
          <TD><TT>GG_CLASS_ACK</TT></TD>
          <TD><TT>0x0020</TT></TD>
          <TD>Klient nie ¿yczy sobie potwierdzenia 
      wiadomo¶ci.</TD></TR></TBODY></TABLE></CENTER>
      <P>D³ugo¶æ tre¶ci wiadomo¶ci nie powinna przekraczaæ 2000 znaków. 
      <P>Oryginalny klient wysy³aj±c wiadomo¶æ do kilku u¿ytkowników, wysy³a po 
      kilka takich samych pakietów z ró¿nymi numerkami odbiorców. Nie ma 
      osobnego pakietu do tego. Natomiast je¶li chodzi o <I>po³±czenia 
      konferencyjne</I> do pakietu doklejana jest nastêpuj±ca struktura: 
      <P>
      <P><PRE>	struct gg_msg_recipients {
		char flag;		<I>/* == 1 */</I>
		int count;		<I>/* ilo¶æ odbiorców */</I>
		int recipients[];	<I>/* tablica odbiorców */</I>
	};
</PRE>
      <P></P>Na przyk³ad, by wys³aæ do dwóch osób, nale¿y wys³aæ pakiet: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Offset</B></TD>
          <TD><B>Warto¶æ</B></TD></TR>
        <TR>
          <TD><I>n</I></TD>
          <TD>Tre¶æ wiadomo¶ci</TD></TR>
        <TR>
          <TD><I>m</I></TD>
          <TD><TT>0x01</TT></TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;1</TD>
          <TD rowSpan=4><TT>0x02</TT></TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;2</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;3</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;4</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;5</TD>
          <TD rowSpan=4>Numer pierwszego adresata</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;6</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;7</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;8</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;9</TD>
          <TD rowSpan=4>Numer drugiego adresata</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;10</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;11</TD></TR>
        <TR>
          <TD><I>m</I>&nbsp;+&nbsp;12</TD></TR></TBODY></TABLE></CENTER>
      <P>Od wersji 4.8.1 mo¿liwe jest równie¿ dodawanie do wiadomo¶ci ró¿nych 
      atrybutów tekstu jak pogrubienie czy kolory. Niezbêdne jest do³±czenie 
      nastêpnuj±cej struktury: 
      <P>
      <P><PRE>	struct gg_msg_richtext {
		char flag;	<I>/* == 2 */</I>
		short length;	<I>/* d³ugo¶æ dalszej czê¶ci */</I>
	};
</PRE>
      <P></P>Dalsza czê¶æ pakietu zawiera odpowiedni± ilo¶æ struktur o ³±czej 
      d³ugo¶ci okre¶lonej polem <TT>length</TT>: 
      <P>
      <P><PRE>	struct gg_msg_richtext_format {
		short position;	<I>/* pozycja atrybutu w tek¶cie */</I>
		char font;	<I>/* atrybuty czcionki */</I>
		char rgb[3];	<I>/* kolor czcionki, nie musi wyst±piæ */</I>
	};
</PRE>
      <P></P>Ka¿da z tych struktur okre¶la kawa³ek tekstu pocz±wszy od znaku 
      okre¶lonego przez pole <TT>position</TT> (liczone od zera) a¿ do 
      nastêpnego wpisu lub koñca tekstu. Pole <TT>font</TT> jest map± bitow± i 
      kolejne bity maj± nastêpuj±ce znaczenie: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Etykieta</B></TD>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD><TT>GG_FONT_BOLD</TT></TD>
          <TD><TT>0x01</TT></TD>
          <TD>Pogrubiony tekst</TD></TR>
        <TR>
          <TD><TT>GG_FONT_ITALIC</TT></TD>
          <TD><TT>0x02</TT></TD>
          <TD>Kursywa</TD></TR>
        <TR>
          <TD><TT>GG_FONT_UNDERLINE</TT></TD>
          <TD><TT>0x04</TT></TD>
          <TD>Podkre¶lenie</TD></TR>
        <TR>
          <TD><TT>GG_FONT_COLOR</TT></TD>
          <TD><TT>0x08</TT></TD>
          <TD>Kolorowy tekst. Tylko w tym wypadku struktura 
            <TT>gg_msg_richtext_format</TT> zawiera pole <TT>rgb[]</TT> bêd±ce 
            opisem trzech sk³adowych koloru, kolejno czerwonej, zielonej i 
            niebieskiej.</TD></TR></TBODY></TABLE></CENTER>
      <P>Dla przyk³adu, by przes³aæ tekst ,,ala <B>ma</B> kota'', nale¿y 
      do³±czyæ do wiadomo¶ci nastêpuj±c± sekwencjê bajtów: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Offset</B></TD>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD><I>n</I></TD>
          <TD><TT>0x02</TT></TD>
          <TD>Opis atrybutów tekstu...</TD></TR>
        <TR>
          <TD><I>n</I> + 1</TD>
          <TD rowSpan=2><TT>0x0006</TT></TD>
          <TD rowSpan=2>...maj±cy 6 bajtów d³ugo¶ci</TD></TR>
        <TR>
          <TD><I>n</I> + 2</TD></TR>
        <TR bgColor=#f0f0f0>
          <TD><I>n</I> + 3</TD>
          <TD rowSpan=2><TT>0x0004</TT></TD>
          <TD rowSpan=2>Atrybut zaczyna siê od pozycji 4...</TD></TR>
        <TR bgColor=#f0f0f0>
          <TD><I>n</I> + 4</TD></TR>
        <TR bgColor=#f0f0f0>
          <TD><I>n</I> + 5</TD>
          <TD><TT>0x01</TT></TD>
          <TD>...i jest to pogrubiony tekst</TD>
        <TR>
          <TD><I>n</I> + 6</TD>
          <TD rowSpan=2><TT>0x0006</TT></TD>
          <TD rowSpan=2>Atrybut zaczyna siê od pozycji 6...</TD></TR>
        <TR>
          <TD><I>n</I> + 7</TD></TR>
        <TR>
          <TD><I>n</I> + 8</TD>
          <TD><TT>0x00</TT></TD>
          <TD>...i jest to zwyk³y tekst</TD></TR></TBODY></TABLE></CENTER>
      <P>Serwer po otrzymaniu wiadomo¶ci odsy³a potwierdzenie, które przy okazji 
      mówi nam, czy wiadomo¶æ dotar³a do odbiorcy czy zosta³a zakolejkowana z 
      powodu nieobecno¶ci. Otrzymujemy je w postaci pakietu: 
      <P>
      <P><PRE>	#define GG_SEND_MSG_ACK 0x0005
	
	struct gg_send_msg_ack {
		int status;	<I>/* stan wiadomo¶ci */</I>
		int recipient;	<I>/* numer odbiorcy */</I>
		int seq;	<I>/* numer sekwencyjny */</I>
	};
</PRE>
      <P></P>Numer sekwencyjny i numer adresata s± takie same jak podczas 
      wysy³ania, a stan wiadomo¶ci mo¿e byæ jednym z nastêpuj±cych: 
      <P>
      <CENTER>
      <TABLE cellSpacing=0 cellPadding=2 border=1>
        <TBODY>
        <TR bgColor=silver>
          <TD><B>Etykieta</B></TD>
          <TD><B>Warto¶æ</B></TD>
          <TD><B>Znaczenie</B></TD></TR>
        <TR>
          <TD><TT>GG_ACK_DELIVERED</TT></TD>
          <TD><TT>0x0002</TT></TD>
          <TD>Wiadomo¶æ dostarczono</TD></TR>
        <TR>
          <TD><TT>GG_ACK_QUEUED</TT></TD>
          <TD><TT>0x0003</TT></TD>
          <TD>Wiadomo¶æ zakolejkowano</TD></TR>
        <TR>
          <TD><TT>GG_ACK_MBOXFULL</TT></TD>
          <TD><TT>0x0004</TT></TD>
          <TD>Wiadomo¶ci nie dostarczono. Skrzynka odbiorcza na serwerze jest 
            pe³na (20 wiadomo¶ci maks). Wystêpuje tylko w trybie offline</TD></TR>
        <TR>
          <TD><TT>GG_ACK_NOT_DELIVERED</TT></TD>
          <TD><TT>0x0006</TT></TD>
          <TD>Wiadomo¶ci nie dostarczono. Odpowied¼ ta wystêpuje tylko w 
            przypadku wiadomo¶ci klasy 
      <TT>GG_CLASS_CTCP</TT></TD></TR></TBODY></TABLE></CENTER>
      <P>
      <HR>

      <H3>1.7. Otrzymywanie wiadomo¶ci</H3>
      <P>Wiadomo¶ci serwer przysy³a za pomoc± pakietu: 
      <P>
      <P><PRE>	#define GG_RECV_MSG 0x000a
	
	struct gg_recv_msg {
		int sender;		<I>/* numer nadawcy */</I>
		int seq;		<I>/* numer sekwencyjny */</I>
		int time;		<I>/* czas nadania */</I>
		int class;		<I>/* klasa wiadomo¶ci */</I>
		char message[];		<I>/* tre¶æ wiadomo¶ci */</I>
	};
</PRE>
      <P></P>Czas nadania jest zapisany w postaci UTC, jako ilo¶ci sekund od 1 
      stycznie 1970r. W przypadku pakietów ,,konferencyjnych'' na koñcu pakietu 
      doklejona jest struktura identyczna z <TT>gg_msg_recipients</TT> 
      zawieraj±ca pozosta³ych rozmówców. 
      <HR>

      <H3>1.8. Ping, pong</H3>
      <P>Od czasu do czasu klient wysy³a pakiet do serwera, by oznajmiæ, ¿e 
      po³±czenie jeszcze jest utrzymywane. Je¶li serwer nie dostanie takiego 
      pakietu w przeci±gu 5 minut, zrywa po³±czenie. To, czy klient dostaje 
      odpowied¼ zmienia siê z wersji na wersjê, wiêc najlepiej nie polegaæ na 
      tym. 
      <P>
      <P><PRE>	#define GG_PING 0x0008
	
	#define GG_PONG 0x0007
</PRE>
      <P></P>
      <HR>

      <H3>1.9. Roz³±czenie</H3>
      <P>Je¶li serwer zechce nas roz³±czyæ, wy¶le wcze¶niej pusty pakiet: 
      <P>
      <P><PRE>	#define GG_DISCONNECTING 0x000b
</PRE>
      <P></P>Ma to miejsce, gdy próbowano zbyt wiele razy po³±czyæ siê z 
      nieprawid³owym has³em, lub gdy równocze¶nie po³±czy siê drugi klient z tym 
      samym numerem (nowe po³±czenie ma wiêkszy priorytet). 
      <HR>

      <H2>2. Us³ugi HTTP</H2>
      <P>Opis znajduje siê w pliku <A 
      href="file:///D:/tmp/doc/http.txt">http.txt</A>. 
      <HR>

      <H2>3. Bezpo¶rednie po³±czenie</H2>
      <P>Opis znajduje siê w pliku <A 
      href="file:///D:/tmp/doc/dcc-protocol.txt">dcc-protocol.txt</A>. <A 
      name=ch4>
      <HR>

      <H2>4. Autorzy</H2>
      <P>Autorami powy¿szego opisu s±: 
      <UL>
        <LI>Wojtek Kaniewski (wojtekka%irc.pl): pierwsza wersja opisu, poprawki, 
        utrzymanie wszystkiego w porz±dku. 
        <LI>Robert J. Wo¼ny (speedy%atman.pl): opis nowo¶ci w protokole GG 4.6, 
        poprawki. 
        <LI>Tomasz Jarzynka (tomee%cpi.pl): badanie timeoutów. 
        <LI>Adam Ludwikowski (adam.ludwikowski%wp.pl): wiele poprawek, wersje 
        klientów, rozszerzone wiadomo¶ci, powody nieobecno¶ci. 
        <LI>Marek Kozina (klith%hybrid.art.pl): czas otrzymania wiadomo¶ci. 
        <LI>Rafa³ Florek (raf%regionet.regionet.pl): opis po³±czeñ 
        konferencyjnych. 
        <LI>Igor Popik (igipop%wsfiz.edu.pl): klasy wiadomo¶ci przy odbieraniu 
        zakolejkowanej. 
        <LI>Rafa³ Cyran (ajron%wp.pl): informacje o remote_port, rodzaje 
        potwierdzeñ przy ctcp, GG_LOGIN_EXT. 
        <LI>Piotr Mach (pm%gadu-gadu.com): ilo¶æ kontaktow, pe³na skrzynka, 
        pusta lista, maska audio, us³ugi HTTP, GG_LOGIN_EXT. 
        <LI>Adam Czy¶ciak (acc%interia.pl): potwierdzenie wiadomo¶ci 
        GG_CLASS_ACK. 
        <LI>Kamil Dêbski (kdebski%kki.net.pl): czas w stanach opisowych. 
        <LI>Pawe³ Piwowar (alfapawel%go2.pl): format czasu. 
        <LI>Tomasz Chiliñski (chilek%chilan.com): nowo¶ci w 5.0.2. </LI></UL>
      <HR>
      <FONT color=silver>$Id: protocol.html,v 1.19 2002/12/26 14:31:52 wojtekka 
      Exp $ </FONT></A></TD></TD></TR></TBODY></TABLE></CENTER></BODY></HTML>
